using System;
using System.Buffers;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Threading.Tasks;

using Google.Protobuf;
using Grpc.Core;

using Helloworld;

namespace CopyServer
{
    // Override server base generated by protogen to implement
    public class CopierImplementation : Copier.CopierBase
    {
        public override async Task Copy(CopyRequest request, IServerStreamWriter<CopyReply> responseStream, ServerCallContext context)
        {
            try
            {
                Console.WriteLine($"received request for {request.Name}");

                FileStreamAndHeaders streamAndHeaders = GetFileStreamAndHeaders(request);
                using (streamAndHeaders.Stream)
                {
                    await context.WriteResponseHeadersAsync(streamAndHeaders.GetHeaders()).ConfigureAwait(false);

                    if (streamAndHeaders.Error is null)
                    {
                        Debug.Assert(!(streamAndHeaders.Stream is null));
                        Debug.Assert(streamAndHeaders.ChunkSize > 0);
                        byte[] buffer = new byte[streamAndHeaders.ChunkSize];
                        long chunks, bytes;
                        switch (streamAndHeaders.Compression)
                        {
                            case CopyCompression.None:
                                (chunks, bytes) = await StreamContent(streamAndHeaders.Stream, buffer, responseStream).ConfigureAwait(false);
                                break;
                            case CopyCompression.Gzip:
                                (chunks, bytes) = await StreamContentWithCompression(streamAndHeaders.Stream, buffer, responseStream).ConfigureAwait(false);
                                break;
                            default:
                                throw new NotSupportedException();
                        }
                        Console.WriteLine($"wrote {bytes} bytes in {chunks} chunks");
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                throw;
            }
        }

        private class FileStreamAndHeaders
        {
            public Stream Stream;

            public string FileName;

            public long Offset;

            public long FileSize = -1L;

            public int ChunkSize = -1;

            public CopyCompression Compression;

            public Exception Error;

            public Metadata GetHeaders ()
            {
                Metadata headers = new Metadata();
                headers.Add("fileName", FileName);
                headers.Add("offset", Offset.ToString());
                if (FileSize >= 0) headers.Add("fileSize", FileSize.ToString());
                if (ChunkSize >= 0) headers.Add("chunkSize", ChunkSize.ToString());
                if (Compression == CopyCompression.Gzip) headers.Add("compression", Compression.ToString());
                if (Error is null)
                {
                    headers.Add("success", "true");
                }
                else
                {
                    headers.Add("success", "false");
                    headers.Add("exception", Error.GetType().Name);
                    headers.Add("message", Error.Message);
                }
                return (headers);
            }

        }

        private FileStreamAndHeaders GetFileStreamAndHeaders (CopyRequest request)
        {
            FileStreamAndHeaders result = new FileStreamAndHeaders();

            try
            {
                result.FileName = request.Name;

                result.Offset = request.Offset;

                result.Stream = new FileStream(request.Name, FileMode.Open, FileAccess.Read, FileShare.Read, CopyConstants.BufferSize, FileOptions.Asynchronous | FileOptions.SequentialScan);

                result.FileSize = result.Stream.Length;

                Debug.Assert(result.Stream.Position == 0L);
                result.Stream.Seek(request.Offset, SeekOrigin.Begin);
                Debug.Assert(result.Stream.Position == request.Offset);

                result.ChunkSize = CopyConstants.BufferSize;

                // Decide whether to use compression.
                if (request.Compression == CopyCompression.Gzip && result.FileSize > CopyConstants.BigSize)
                {
                    result.Compression = CopyCompression.Gzip;
                }
            }
            catch (Exception e)
            {
                result.Error = e;
            }

            return (result);

        }

        private async Task<(long, long)> StreamContentWithCompression (Stream reader, byte[] buffer, IServerStreamWriter<CopyReply> responseStream)
        {
            Debug.Assert(!(reader is null));
            Debug.Assert(!(responseStream is null));

            long bytes = 0L;
            long chunks = 0L;            
            using (Stream grpcStream = new BufferedWriteStream(
                buffer,
                async (byte[] bf, int offset, int count) =>
                {
                    ByteString content = ByteString.CopyFrom(bf, offset, count);
                    CopyReply reply = new CopyReply() { Content = content, Index = chunks };
                    await responseStream.WriteAsync(reply);
                    bytes += count;
                    chunks++;
                }
            ))
                
            {
                using (Stream compressionStream = new GZipStream(grpcStream, System.IO.Compression.CompressionLevel.Fastest, true))
                {
                    await reader.CopyToAsync(compressionStream, buffer.Length).ConfigureAwait(false);
                    await compressionStream.FlushAsync().ConfigureAwait(false);
                }
                await grpcStream.FlushAsync().ConfigureAwait(false);
            }

            return (chunks, bytes);

        }

        private async Task CopyContent(string file, IServerStreamWriter<CopyReply> responseStream)
        {
            byte[] buffer = File.ReadAllBytes(file);
            ByteString content = ByteString.CopyFrom(buffer, 0, buffer.Length);
            CopyReply reply = new CopyReply() { Content = content, Index = 0 };
            await responseStream.WriteAsync(reply).ConfigureAwait(false);
        }

        // It's quite easy to stream without compression using the same
        // logic as with compression; just CopyToAsync(grpcStream) directly.
        // But that adds an extra buffer (inside the CopyToAsync method) and
        // a corresponding extra copy. So we keep the direct stream without
        // compression logic seperate.
        private async Task<(long, long)> StreamContent (Stream reader, byte[] buffer, IServerStreamWriter<CopyReply> responseStream)
        {
            Debug.Assert(!(reader is null));
            Debug.Assert(!(responseStream is null));

            long bytes = 0L;
            long chunks = 0;
            while (true)
            {
                int chunkSize = await reader.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false);
                if (chunkSize == 0) break;

                ByteString content = ByteString.CopyFrom(buffer, 0, chunkSize);
                CopyReply reply = new CopyReply() { Content = content, Index = chunks };
                await responseStream.WriteAsync(reply).ConfigureAwait(false);

                bytes += chunkSize;
                chunks++;
            }

            return (chunks, bytes);
        } 
    }
}
